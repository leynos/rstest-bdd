# Debugging Plan: runtime test expects if-let guard in generated step executor

**Generated**: 2026-01-04T03:13:03Z  
**Issue ID**: rstest-bdd-macros codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from  
**Severity**: Medium

## Problem Statement

The unit test `codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from` fails, panicking because it cannot find an `if` expression in the generated `__rstest_bdd_execute_single_step` function. The test expects an `if let` guard around `find_step_with_metadata(...)` with a `StepText::from(text)` argument. The generated code likely no longer includes that `if let`, causing the AST-based assertions to fail and the CI coverage run to abort.

## Context Summary

| Aspect | Details |
|--------|---------|
| First observed | Reported in CI failure log (date unknown) |
| Reproduction rate | Consistent in CI run shown |
| Affected components | `crates/rstest-bdd-macros/src/codegen/scenario/runtime` (test and generator) |
| Recent changes | Refactors in step executor generation (unknown commit) |

### Error Artefacts

```
thread 'codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from' panicked at crates/rstest-bdd-macros/src/codegen/scenario/runtime/tests.rs:31:10:
expected statements to contain an if expression
```

### Information Gaps

- The exact commit or refactor that changed the generated code structure.
- Whether the intended behaviour is to keep the `if let` guard or accept a new `let`/`unwrap_or_else` pattern and update tests.

---

## Hypotheses

### H1: The generator now uses `let step = find_step_with_metadata(...).unwrap_or_else(...)` instead of `if let Some(step) = ...`

**Claim**: `generate_step_executor` no longer emits an `if let` statement, so `extract_if_expr` cannot find an `ExprIf` in the top-level statements.

**Plausibility**: High — the test explicitly looks for `if let` and fails; the current generator code likely uses `unwrap_or_else` for a more direct panic path.

**Prediction**: Inspecting the generated tokens or the generator source will show `let step = find_step_with_metadata(...).unwrap_or_else(...)` without any `if let` expression.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Inspect `generate_step_executor` output by parsing tokens in a quick debug test or printing `generate_step_executor().to_string()` | `if let` appears in the output, disproving H1 |
| 2 | Open `crates/rstest-bdd-macros/src/codegen/scenario/runtime/generators/step.rs` and confirm the step lookup expression | Code still contains an `if let Some(step)` branch |

**Tooling**: `rg`, `cargo test -p rstest-bdd-macros --lib codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from -- --nocapture`, or a small `dbg!(generate_step_executor().to_string())` in the test.

**Confidence on falsification**: High — the presence/absence of `if let` is decisive.

---

### H2: The `if let` exists but is nested inside a block and not a top-level statement

**Claim**: The generator still emits an `if let`, but it is wrapped inside another statement/block (e.g., inside a `match` or `let`), so the test helper that scans top-level statements fails.

**Plausibility**: Medium — refactors that wrap logic in a helper closure or block can hide the `if` from the simple scan.

**Prediction**: The AST contains an `ExprIf`, but it is not a direct `syn::Stmt::Expr` at the top level.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Dump or traverse the AST of the generated function body and list statement kinds | `ExprIf` appears at the top-level statements list |

**Tooling**: Add a temporary AST traversal in the test or use `syn::visit` to log expression kinds.

**Confidence on falsification**: Medium — confirms whether test logic needs to be updated.

---

### H3: The test should be updated to match the new step lookup form rather than forcing an `if let`

**Claim**: The generator change is intended, and the test is outdated; it should assert that the step lookup uses `StepText::from(text)` regardless of whether it is inside an `if let` or an `unwrap_or_else` chain.

**Plausibility**: Medium — generator refactors often change surface AST while preserving semantics.

**Prediction**: The generated code uses `StepText::from(text)` but not within an `if let`, so adjusting the test to search for the call expression would pass.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Search the generated AST for a call to `find_step_with_metadata` and verify its second arg is `StepText::from(text)` | No such call exists, indicating a deeper regression |

**Tooling**: Extend the test to locate `ExprCall` nodes with `find_step_with_metadata` and inspect args.

**Confidence on falsification**: Medium — confirms whether the test should be updated versus rolling back generator changes.

---

## Recommended Execution Order

1. **H1** — cheapest check: inspect generator source / output for `if let` vs `unwrap_or_else`.
2. **H2** — if H1 is false, confirm whether the `if let` moved into a nested block.
3. **H3** — if `if let` is truly gone but `StepText::from(text)` remains, update the test to assert on the call shape rather than the `if`.

## Termination Criteria

- **Root cause identified**: One hypothesis remains consistent with the generated AST while others are falsified.
- **Escalation trigger**: If neither `if let` nor a valid `find_step_with_metadata(StepText::from(text))` call exists, revisit generator logic for regressions.

## Notes for Executing Agent

- Run only the single failing test first to keep feedback tight.
- Preserve current generator behaviour unless product requirements explicitly require an `if let` guard; update tests if semantics are equivalent.
