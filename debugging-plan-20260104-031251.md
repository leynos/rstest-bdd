# Debugging Plan: runtime test expects if-let guard in generated step executor

**Generated**: 2026-01-04T03:13:03Z **Issue ID**:

<!-- markdownlint-disable-next-line MD013 -->

`rstest-bdd-macros codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from`
**Severity**: Medium

## Problem Statement

The unit test is:

<!-- markdownlint-disable-next-line MD013 -->

`codegen::scenario::runtime::tests::execute_single_step_looks_up_steps_with_steptext_from`.

It fails because it cannot find an `if` expression in the generated
`__rstest_bdd_execute_single_step` function. The test expects an `if let` guard
around `find_step_with_metadata(...)` with a `StepText::from(text)` argument.
The generated code likely no longer includes that `if let`, causing AST-based
assertions to fail and the CI coverage run to abort.

## Context Summary

| Aspect              | Details                                                |
| ------------------- | ------------------------------------------------------ |
| First observed      | Reported in CI failure log (date unknown)              |
| Reproduction rate   | Consistent in CI run shown                             |
| Affected components | `rstest-bdd-macros` runtime test + generator           |
| Recent changes      | Refactors in step executor generation (unknown commit) |

### Error Artefacts

```text
thread 'codegen::scenario::runtime::tests::'
execute_single_step_looks_up_steps_with_steptext_from' panicked at
crates/rstest-bdd-macros/src/codegen/scenario/runtime/tests.rs:31:10:
expected statements to contain an if expression
```

### Information Gaps

- The exact commit or refactor that changed the generated code structure.
- Whether the intended behaviour is to keep the `if let` guard or accept a new
  `let`/`unwrap_or_else` pattern and update tests.

______________________________________________________________________

## Hypotheses

### H1: Step lookup uses `unwrap_or_else` instead of `if let`

**Claim**: `generate_step_executor` now emits
`let step = find_step_with_metadata(...).unwrap_or_else(...)` and removes the
`if let` guard, so `extract_if_expr` cannot find an `ExprIf` in top-level
statements.

**Plausibility**: High — the test explicitly looks for `if let`, and refactors
often replace it with `unwrap_or_else` for a direct panic path.

**Prediction**: Inspecting the generated tokens or generator source will show
`unwrap_or_else` and no `if let` guard.

#### Falsification Plan (H1)

- Step 1: Inspect generated tokens (parse or
  `dbg!(generate_step_executor().to_string())`). Expected negative result:
  `if let` appears in the output.
- Step 2: Open
  `crates/rstest-bdd-macros/src/codegen/scenario/runtime/generators/step.rs`
  and confirm the step lookup expression. Expected negative result: code still
  uses `if let Some(step)`.

**Tooling**: `rg`, `cargo test -p rstest-bdd-macros --lib`
`codegen::scenario::runtime::tests::`
`execute_single_step_looks_up_steps_with_steptext_from -- --nocapture`.

**Confidence on falsification**: High — presence or absence of `if let` is
decisive.

______________________________________________________________________

### H2: The `if let` exists but is nested and not top-level

**Claim**: The generator still emits an `if let`, but it is wrapped inside a
nested block or helper, so the test helper that scans top-level statements
fails.

**Plausibility**: Medium — refactors can wrap logic in blocks or helper
closures, hiding the `if` from a simple scan.

**Prediction**: The AST contains an `ExprIf`, but it is not a direct
`syn::Stmt::Expr` in the top-level list.

#### Falsification Plan (H2)

- Step 1: Traverse the AST of the generated function body and list statement
  kinds. Expected negative result: `ExprIf` appears at the top level.

**Tooling**: Add a temporary AST traversal in the test or use `syn::visit` to
log expression kinds.

**Confidence on falsification**: Medium — confirms whether test logic needs
updating.

______________________________________________________________________

### H3: The test should assert the call shape, not the `if let`

**Claim**: The generator change is intended, and the test is outdated; it
should assert that the step lookup uses `StepText::from(text)` regardless of
`if let` vs `unwrap_or_else`.

**Plausibility**: Medium — generator refactors often change AST shape while
preserving semantics.

**Prediction**: The generated code still uses `StepText::from(text)` even
without an `if let`, so a call-based assertion would pass.

#### Falsification Plan (H3)

- Step 1: Search the generated AST for a call to `find_step_with_metadata` and
  verify its second argument is `StepText::from(text)`. Expected negative
  result: no such call exists, indicating a deeper regression.

**Tooling**: Extend the test to locate `ExprCall` nodes with
`find_step_with_metadata` and inspect arguments.

**Confidence on falsification**: Medium — distinguishes between outdated tests
and genuine regressions.

______________________________________________________________________

## Recommended Execution Order

1. **H1** — cheapest check: inspect generator source or output for `if let` vs
   `unwrap_or_else`.
1. **H2** — if H1 is false, confirm whether the `if let` moved into a nested
   block.
1. **H3** — if `if let` is gone but `StepText::from(text)` remains, update the
   test to assert on call shape rather than the `if`.

## Termination Criteria

- **Root cause identified**: one hypothesis survives while others are falsified.
- **Escalation trigger**: if neither `if let` nor a valid
  `find_step_with_metadata(StepText::from(text))` call exists, revisit
  generator logic for regressions.

## Notes for Executing Agent

- Run only the single failing test first to keep feedback tight.
- Preserve current generator behaviour unless product requirements explicitly
  require an `if let` guard; update tests if semantics are equivalent.
